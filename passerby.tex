%-----------------------------------------------------------------------
% Beginning of article-template.tex
%-----------------------------------------------------------------------
%
%    This is a template file for proceedings articles prepared with AMS
%    author packages, for use with AMS-LaTeX.
%
%    Templates for various common text, math and figure elements are
%    given following the \end{document} line.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%    Remove any commented or uncommented macros you do not use.

%    Replace amsproc by the name of the author package.
\documentclass{amsart}

%    If you need symbols beyond the basic set, uncomment this command.
%\usepackage{amssymb}

%    If your article includes graphics, uncomment this command.
%\usepackage{graphicx}

%    If the article includes commutative diagrams, ...
%\usepackage[cmtip,all]{xy}

%    Include other referenced packages here.
% \usepackage{}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{fancyvrb}
\usepackage{amsmath}
% See http://tex.stackexchange.com/questions/32051/variable-sized-such-that-pipe
% For usage of /Set that depends on braket
\usepackage{braket}
% For showing images:
% \usepackage{svg}
% For showing text images:
% \usepackage{pstricks}

% For showing images:
\usepackage{graphicx}
% \usepackage{svg}

%    Update the information and uncomment if AMS is not the copyright
%    holder.
%\copyrightinfo{2009}{American Mathematical Society}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{xca}[theorem]{Exercise}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\numberwithin{equation}{section}

\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\divides}{\mid}

\begin{document}


\title{Passerby messaging system}
%    Only \author and \address are required; other information is
%    optional.  Remove any unused author tags.

%    author one information
% \author[short version for running head]{name for top of paper}
\author{real}
% \address{freedomlayer}
% \curraddr{}
\email[real]{real@freedomlayer.org}
\thanks{Freedomlayer research facility}

%    author two information
% \author{}
% \address{}
% \curraddr{}
% \email{}
% \thanks{}

% \subjclass[2000]{Primary}
%    The 2010 edition of the Mathematics Subject Classification is
%    now available.  If you are citing a classification from the
%    new scheme, use the following input coding instead.
% See http://www.ams.org/msc/msc2010.html?t=05C30&btn=Current for explanation.
\subjclass[2010]{Primary 05C30}

\date{22.06.2017}
\maketitle

\begin{abstract}
  Passerby is an experimental messaging system that allows real time anonymous
  and encrypted messaging. This document describes the protocol being used in
  Passerby.
\end{abstract}

\section{Main goals}

Main goals of the Passerby system:

\begin{enumerate}
  \item Passing messages between people with high probability of success.
  \item Encrypting the messages passed between people.
  \item Keeping a contact list.
\end{enumerate}


\section{Low level API messages}

Possible messages to send to the Passerby router:
\begin{enumerate}
  \item $SendMessage (remoteId, datagramData)$
\end{enumerate}

Possible messages to receive from the Passerby router:
\begin{enumerate}
  \item $MessageReceived (remoteId, datagramData)$
\end{enumerate}

Node ids are of size 120 bits (15 bytes). They are a hash of a public key.

\section{Protocol routing messages}

The structure of a message:

\begin{enumerate}
  \item magic
  \item messageType
  \item length (of payload, in bytes)
  \item payload
\end{enumerate}

\subsection{Messages between routing engines}

The Passerby router has direct reliable TCP like connections to various nodes,
implemented somehow. For any direct connection with a neighboring node, the
following messages can be transferred.

\begin{enumerate}
  \item $UpdatedGlobalTowerPath(towerColor, SignedPathFromTower)$
      Used both for new choice of a global tower, or changes in the network layout.
      In the beginning of connection, this message should be sent for all known
      global towers. 
      \[
        globalTower,  timestamp                     \\
        a_1,          sign[globalTower](a_1, prev)  \\
        a_2,          sign[a_1](a_2, prev)          \\
        \cdots                                      \\
        a_k,          sign[a_k](a_{k-1}, prev)
      \]

  \item $UpdatedLocalTowerPath(towerColor, towerIndex, SignedPathFromTower)$
      Used both for new choice of a local tower, or changes in the network
      layout. In the beginning of connection, this message should be sent for
      all known local towers. 
      \[
        localTower,   timestamp                     \\
        a_1,          sign[localTower](a_1, prev)   \\
        a_2,          sign[a_1](a_2, prev)          \\
        \cdots                                      \\
        a_k,          sign[a_{k-1}](a_k, prev)
      \]

  \item $RegisterLocalTower(towerColor, SignedPathToTower)$
      A node registers with a local tower.
      \[
        nodeId,       timestamp                   \\
        a_1,          sign[nodeId](a_1, prev)    \\
        a_2,          sign[a_1](a_2, prev)        \\
        \cdots                                    \\
        localTower,   sign[a_{k-1}](localTower, prev)
      \]
      The local tower will keep knowledge of paths to all nodes in the given
      chain of signatures.


  \item $SendMessageLocalTower(towerColor, destNodeId, content)$
    Send a message with given content to a destination id.
    This message will be first passed to the closest local Tower of color
    towerColor. The towers will then handle the messages delivery. This message
    originates at some node and arrives at a local tower.

  \item $MessageReceivedLocalTower(NodeIdPath, content)$
    A message received through the local tower with given content.
    IdPath is a list of Ids that show how to route the message to the correct
    id (According to the knowledge of the local tower).
    This message originates at a local tower and arrives at the relevant node.

\end{enumerate}


\subsection{Messages between Towers}

The towers are the mechanism used for long range routing of messages.
Each tower should know the location of all the other towers, to be able to route
messages quickly between towers.

\begin{enumerate}
  \item $PathFromTowerLocal(destTowerColor, originTowerColor, originTowerIndex, 
    SignedPathFromTower)$
    A path from remote local tower, sent to the closest tower of color destTowerColor.

  \item $PathFromTowerGlobal(originTowerColor, SignedPathFromTower)$
    A path from remote global tower, sent as a broadcast to all the nodes in the
    network.

  \item $LookupIdRequest(RequesterTowerColor, RequesterTowerIndex, nodeId)$
    Find out which tower is responsible for the node nodeId.

  \item $LookupIdResponse(RequesterTowerColor, RequesterTowerIndex, nodeId, 
    [(TowerColor, TowerId)])$
    Respond with the list of towers that have responsibility for nodeId.

  \item $RouteMessage(destTowerColor, destTowerIndex, destNodeId, content)$
    Route a message between towers until it arrives at destTowerId.
    (Then destTowerId will send a MessageReceivedLocalTower to destNodeId)
\end{enumerate}


\section{Operation of one node}

\subsection{The towers selection functions}

We assume that every node in the network has access to the current time in UTC
form. Given the current time (in seconds since epoch), $time$, we define:

$tcolor(color, time) := ((time / timeBlock) + color) / numColors$

We choose timeBlock to be 900 seconds, which are 15 minutes. We also choose
$num_colors = 8$, and therefore $color \in [numColors] = [8]$.

For every passage of $timeBlock$, the tcolor of only one color changes. In other
words, given some time $t_0$ there is some color $c_0$ such that $tcolor(c_0,t_0) +
1 = tcolor(c_0, t_0 + timeBlock)$, and for every $c \neq c_0$ we get that
$tcolor(c,t_0) = tcolor(c, t_0 + timeBlock)$

Next we define:

\[ 
  h(color, index, time) := sha256(``AA'' | tcolor(color, time) | ``BB'' | color |
    ``CC'' | index ) \\

  towerNodeMatch(nodeId, color, index, time) := sha256(``DD'' |  h(color, index, time) | 
    ``EE'' | sha256(nodeId))

\]

During time $time$, the tower with color $c$ and index $i$ is the node that
minimizes the value of $towerNodeMatch(nodeId, c, i, time)$ (Considered as a
number in big endian notation). If there is a tie, the value $nodeId$ is used as
a tie breaker.

The global tower of color $c$ is the tower with color $c$ and index $0$.

\subsection{Maintained data structures for every node}

Every node should keep the following:

\begin{enumerate}
  \item Local Towers (Closest for each color):
    Distance and gateways (neighboring nodes).
  \item Global Towers (For each color, with index = 0):
    Distance and gateways (neighboring nodes).
\end{enumerate}

Nodes that are towers also maintain the following:

% TODO: Make sure that the things below are consistent:

\begin{enumerate}
  \item For every registered node:
    \begin{enumerate}
      \item Time of registration
      \item path to registered node.
    \end{enumerate}
  \item For every tower (color, index > 0):
    \begin{enumerate}
      \item Distance to remote tower.
      \item Gateways to remote tower. Each gateway is a color of a local tower.
    \end{enumerate}
  \item For every global tower (color, index = 0):
    \begin{enumerate}
      \item Distance to remote global tower.
      \item Gateways to remote global tower. Each gateway is a color of a local tower.
    \end{enumerate}

\end{enumerate}


% The structure of an NCMessage (payload):
% \begin{enumerate}
%   \item magic
%   \item Encrypted symmetric key 
%     $Enc_{RemoteId}(SendSymKey)$ (Usually the same SendSymKey)
%   \item Signature encrypted symmetric key with $LocalId$.
%   \item Encrypted message (By the symmetric key SendSymKey)
%     \begin{enumerate}
%       \item counter (To prevent replay)
%       \item padding length (1 byte)
%       \item random padding
%       \item payload length (4 bytes)
%       \item payload
%     \end{enumerate}
% \end{enumerate}


% \subsection{Subsection}


%    Bibliographies can be prepared with BibTeX using amsplain,
%    amsalpha, or (for "historical" overviews) natbib style.
\bibliographystyle{amsplain}
%    Insert the bibliography data here.
\begin{thebibliography}{9}
\bibitem{chord-stoica}
Ion Stoica, Robert Morris, David Karger, M. Frans Kaashoek, Hari Balakrishnan
\textit{Chord: A scalable Peer-to-peer Lookup Service for Internet Applications}
% \\\texttt{http://www.math.ucsd.edu/\~{}ronspubs/81\_04\_small\_trees.pdf}

\bibitem{pushing-chord-overlay}
Thomas Fuhrmann, Pengfei Di, Kendy Kutzner, Curt Cramer
\textit{Pushing Chord into the Underlay: Scalable Routing for Hybrid MANETs}

\bibitem{virtual-ring-routing}
  Matthew Caesar, Miguel Castro, Edmund B. Nightingale, Greg O'Shea, Antony Rowstron
\textit{Virtual Ring Routing: Network Routing Inspired by DHTs}
\\

\end{thebibliography}

\end{document}

