
# Passerby messaging system
By real@freedomlayer.org, freedomlayer research facility.
15.07.2017

## Abstract

Passerby is an experimental messaging system that allows real time anonymous
and encrypted messaging. This document describes the protocol being used in
Passerby.

## Main goals

Main goals of the Passerby system:

- Passing messages between people with high probability of success.
- Encrypting the messages passed between people.
- Keeping a contact list.


## External API messages

Possible messages to send to the Passerby router:

- SendMessage (remoteId, datagramData)

Possible messages to receive from the Passerby router:

- MessageReceived (remoteId, datagramData)

Node ids are of size 120 bits (15 bytes). They are a hash of a public key.


## Protocol routing messages

The structure of a message:

- magic
- messageType
- length (of payload, in bytes)
- payload

## Messages between routing engines

The Passerby router has direct reliable TCP like connections to various nodes,
implemented somehow. For any direct connection with a neighboring node, the
following messages can be transferred:

- **UpdatedLocalTowerPath**(towerColor, SignedPathFromTower)
  Used both for new choice of a local tower, or changes in the network
  layout. This message is sent periodically, originating from tower nodes.

  ```
  localTower,   timestamp                  
  a_1,          sign{localTower}(a_1, prev)
  a_2,          sign{a_1}(a_2, prev)       
  \cdots                                   
  a_k,          sign{a_{k-1}}(a_k, prev)
  ```

- **RegisterLocalTower**(towerColor, SignedPathToTower)
  A node registers with a local tower.
  ```
  nodeId,       timestamp              
  a_1,          sign{nodeId}(a_1, prev)
  a_2,          sign{a_1}(a_2, prev)   
  \cdots                               
  localTower,   sign{a_{k-1}}(localTower, prev)
  ```
  The local tower will keep knowledge of paths to all nodes in the given
  chain of signatures.

- **SendMessageLocalTower**(towerColor, destNodeId, content)
  Send a message with given content to a destination id.
  This message will be first passed to the closest local Tower of color
  towerColor. The towers will then handle the messages delivery. This message
  originates at some node and arrives at a local tower.

- **MessageReceivedLocalTower**(NodeIdPath, encContent)
  A message received through the local tower with given content.
  IdPath is a list of Ids that show how to route the message to the correct
  id (According to the knowledge of the local tower).
  This message originates at a local tower and arrives at the relevant node.

The structure for `encContent` in MessageReceivedLocalTower is as follows:
- senderPublicKey (senderNodeId)
- encSymmetricKey == Encrypt{key=senderPrivateKey}(symmetricKey)
- encDatagramData == Encrypt{key=symmetricKey, nonce=random}(timestamp, datagramData)

## Messages between towers

The towers are the mechanism used for long range routing of messages.
Each tower should know the location of all other towers, to be able to route
messages quickly between towers.

- **UpdatedTowerPath**(originTowerColor, originTowerId, SignedPathFromTower)
  A message that is sent periodically from originTowerId. This message allows
  all towers in the network to know a path to originTowerId.
  This message is transferred using local tower based paths between towers.

- **LookupIdRequest**(RequesterTowerColor, RequesterTowerId, nodeId)
  Find out which tower is responsible for the node nodeId.

- **LookupIdResponse**(RequesterTowerColor, RequesterTowerId, nodeId, 
  [(TowerColor, TowerId)])$
  Respond with the list of towers that have responsibility for nodeId.

- **RouteMessage**(destTowerColor, destTowerId, destNodeId, encContent)
  Route a message between towers until it arrives at destTowerId.
  (Then destTowerId will send a MessageReceivedLocalTower to destNodeId)

## Protocol constants

- `SYM_KEY_CACHE_TIME = 30 minutes`: maximum amount of time an entry could be
  kept in symKeyMap cache.

- `MESSAGE_CACHE_TIME = 1 minute`: the maximum amount of time an entry could
  be kept in the messageCacheMap cache.

- `LOCAL_TOWER_EXPIRY = 1 minute`: The time it takes for knowledge of local
  tower to expire.

- `TOWER_ODD_BITS = 10`: The odds for a node to be a tower of a specific color
  are 2^(-TOWER_ODD_BITS).

- `TOWER_TIME_BLOCK = 900`: 900 seconds, or 15 minutes. Every
  `TOWER_TIME_BLOCK` minutes towers of some color are replaced.

- `NUM_COLORS = 32`.
  `NUM_COLORS >= 3*log(n * 2^(-TOWER_ODD_BITS) * NUM_COLORS)`


## The towers selection functions

We assume that every node in the network has access to the current time in UTC
form. Given the current time (in seconds since epoch), `time`, we define:

```rust
tcolor(color, time) := ((time / TOWER_TIME_BLOCK) + color) / NUM_COLORS
```

Where `0 <= color < NUM_COLORS`.

For every passage of `TOWER_TIME_BLOCK`, the tcolor of only one color changes. In other
words, given some time `t_0` there is some color `c_0` such that `tcolor(c_0,t_0) +
1 = tcolor(c_0, t_0 + TOWER_TIME_BLOCK)`, and for every `c != c_0` we get that
`tcolor(c,t_0) = tcolor(c, t_0 + TOWER_TIME_BLOCK)`.

Next we define:

```rust
h(color, time) := sha256("AA" | tcolor(color, time) | 
                            "BB" | color)

isTower(nodeId, color, time) := sha256("CC" |  
                    h(color, time) | "DD" | sha256(nodeId)) 
                        < 2^(256 - TOWER_ODDS_BITS)
```

During time `time`, a node `nodeId` is a tower of color `c` if `isTower(nodeId,
color, time)` is true.


## Maintained data structures for every node

Every node should keep the following:

Information about local towers (Closest for each color):
- localTower[color].distance
Shortest known distance to this local tower.

- localTower[color].gateways 
A list of neighboring nodes: (nodeId, timestamp)

- localTower[color].towerNodeId: 
The nodeId of the local tower.


Cache for receiving encrypted messages:
- symKeyMap[senderNodeId] == (encSymmetricKey, symmetricKey) 

With `SYM_KEY_CACHE_TIME`, maximum amount of time an entry could be kept in
symKeyMap cache.

Cache for message replay:
- messageCacheMap[encMsgHash] == timestamp

With `MESSAGE_CACHE_TIME`, the maximum amount of time an entry could be kept in
the messageCacheMap cache.


Nodes that are towers also maintain the following:

- For every registered node:
    - registered[nodeId].registrationTime 
    Time of registration

    - registered[nodeId].path
    Path to registered node.


- For every tower (nodeId):
    - tower[nodeId].color
    The color of the remote tower.

    - tower[nodeId].distance
    Distance to remote tower. This is the length of the shortest path known to
    the remote tower.

    - tower[nodeId].gateways 
    Gateways to remote tower. Each gateway is a color of a local tower.


## Algorithm for every node

The following represents an algorithm of operation for a node with node id
myNodeId.


### Receipt of external SendMessage (remoteId, datagramData):
```rust
- Pick a set of three random tower colors: rcolors.
- for towerColor in rcolors:
    - Send a SendMessageLocalTower(towerColor, remoteId, datagramData) to a
      random gateway from the set localTower[towerColor].gateways.
```

### Receipt of SendMessageLocalTower(towerColor, destNodeId, content):

```rust
- if localTower[towerColor].towerNodeId != myNodeId:
    - gatewayId, timestamp  <-- Sample randomly from 
        localTower[towerColor].gateways
    - Send SendMessageLocalTower(towerColor, destNodeId, content) to the
      neighbor gatewayId.
    - return

- Send LookupIdRequest(towerColor, 
    TODO: Not done here.
```


### Receipt of MessageReceivedLocalTower(nodeIdPath, encContent):

```rust
- if nodeIdPath != []
    - nextNode <-- nodeIdPath[-1]
    - Send a MessageReceivedLocalTower(nodeIdPath[:-1], encContent) to the
      node nextNode.
    - return

- encMsgHash <-- sha256(encContent)
- if encMsgHash in messageCacheMap:
    - return

- symmetricKey <-- Decrypt{key=senderPublicKey}(encSymmetricKey)
- if encContent.senderPublicKey not in symKeyMap
    - symKeyMap[encContent.senderPublicKey] <--
             (encContent.encSymmetricKey, symmetricKey)

- if encContent.encSymmetricKey != symKeyMap[encContent.senderPublicKey].encSymmetricKey:
    - symKeyMap[encContent.senderPublicKey] <--
        (encContent.encSymmetricKey, symmetricKey)

- timestamp, datagramData <-- Decrypt{key=symmetricKey}(encContent.encDatagramData)
- if Decrypt failed, return.

- if curTime - timestamp > `MESSAGE_CACHE_TIME`, return

- messageCacheMap[encMsgHash] <-- timestamp

- Send external MessageReceived(senderPublicKey, datagramData)
```


### Receipt of UpdatedLocalTowerPath(towerColor, SignedPathFromTower):

```rust
- if curTime - SignedPathFromTower.timestamp > `LOCAL_TOWER_EXPIRY`
    - return

- Check all signatures. If any signature is invalid, return.
- Verify that the last signature signs over myNodeId. Otherwise, return.

- distance      <-- length of path.
- gateway       <-- last nodeId on chain before myNodeId.
- towerNodeId   <-- first nodeId on the path.
- timestamp     <-- path timestamp.

- if not isTower(towerNodeId, color, curTime):
    - return

- Remove gateways from `localTower[towerColor].gateways` that are older than
  `LOCAL_TOWER_EXPIRY`.

- if len(localTower[towerColor].gateways) == 0:
    - localTower[towerColor] <-- None

- if localTower[TowerColor] is None:
    - localTower[towerColor].distance       <-- distance
    - localTower[towerColor].gateways       <-- set{(gateway, timestamp)}
    - localTower[towerColor].towerNodeId    <-- towerNodeId

    - for neighborId in neighbors:
        - send UpdatedLocalTowerPath(towerColor, SignedPathFromTower
            + (neighborId, sign{myNodeId}(neighborId, prev)) )
    - return

- if distance > localTower[towerColor].distance:
    - return

- if distance < localTower[towerColor].distance:
    - localTower[towerColor].distance       <-- distance
    - localTower[towerColor].gateways       <-- set{(gateway, timestamp)}
    - localTower[towerColor].towerNodeId    <-- towerNodeId

    - for neighborId in neighbors:
        - send UpdatedLocalTowerPath(towerColor, SignedPathFromTower
            + (neighborId, sign{myNodeId}(neighborId, prev)) )
    - return

- if distance == localTower[towerColor].distance:
    - localTower[towerColor].gateways.insert((gateway, timestamp))
    - for neighborId in neighbors:
        - send UpdatedLocalTowerPath(towerColor, SignedPathFromTower
            + (neighborId, sign{myNodeId}(neighborId, prev)) )
    - return
```


### Receipt of RegisterLocalTower(towerColor, SignedPathToTower):




## TODO area:

TODO: Start with messages between routing engines.
Explain what to do when a message is received.

Explain any periodic behaviour, related to time, like registration.

If a longer path of registration passes through a node, the node will delay his
next registration message, hoping that the same large message will pass again.
This is done to save bandwidth.


TODO: **probes**: Add a mechanism to make sure that towers actually pass messages. Every
node should sometimes send probes: Marked messages (Encrypted) sent through
various towers. He then gets acks for those messages. This way a node can know
which towers are the most reliable, and he will use mostly those towers. Towers
that don't pass messages will get less and less messages.

How to design the probe messages?

