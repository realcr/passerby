
# Passerby messaging system
By real@freedomlayer.org, freedomlayer research facility.
15.07.2017

## Abstract

Passerby is an experimental messaging system that allows real time anonymous
and encrypted messaging. This document describes the protocol being used in
Passerby.

## Main goals

Main goals of the Passerby system:

- Passing messages between people with high probability of success.
- Encrypting the messages passed between people.
- Keeping a contact list.


## External API messages

Possible messages to send to the Passerby router:

- SendMessage (remoteId, datagramData)

Possible messages to receive from the Passerby router:

- MessageReceived (remoteId, datagramData)

Node ids are of size 120 bits (15 bytes). They are a hash of a public key.


## Protocol routing messages

The structure of a message:

- magic
- messageType
- length (of payload, in bytes)
- payload

## Messages between routing engines

The Passerby router has direct reliable TCP like connections to various nodes,
implemented somehow. For any direct connection with a neighboring node, the
following messages can be transferred:

- **LowestNodes**(nodeList)
  nodeList is a list with elements of the form:
  (nodeId, sign{nodeId}(timestamp))
  This message is sent periodically between neighboring nodes. The lowest node
  ids are used to approximate the amount of nodes in the network.

- **LowestNodesPinned**(batchStartTime, nodeList)
  nodeList is a list with elements of the form:
  (nodeId, sign{nodeId}(timestamp))
  This message is sent during `NET_APPROX_TIME` time period between nodes.
  batchStartTime is the start time of the batch for which those pinned lowest
  nodes belong to.

- **UpdatedLocalTowerPath**(towerColor, SignedPathFromTower)
  Used both for new choice of a local tower, or changes in the network
  layout. This message is sent periodically, originating from tower nodes.

  ```
  localTower,   timestamp                  
  a_1,          sign{localTower}(a_1, prev)
  a_2,          sign{a_1}(a_2, prev)       
  \cdots                                   
  a_k,          sign{a_{k-1}}(a_k, prev)
  ```

- **RegisterLocalTower**(towerColor, SignedPathToTower)
  A node registers with a local tower.
  ```
  nodeId,       timestamp              
  a_1,          sign{nodeId}(a_1, prev)
  a_2,          sign{a_1}(a_2, prev)   
  \cdots                               
  localTower,   sign{a_{k-1}}(localTower, prev)
  ```
  The local tower will keep knowledge of paths to all nodes in the given
  chain of signatures.

- **SendMessageLocalTower**(towerColor, destNodeId, encContent)
  Send a message with given content to a destination id.
  This message will be first passed to the closest local Tower of color
  towerColor. The towers will then handle the messages delivery. This message
  originates at some node and arrives at a local tower.

- **MessageReceivedLocalTower**(NodeIdPath, encContent)
  A message received through the local tower with given content.
  IdPath is a list of Ids that show how to route the message to the correct
  id (According to the knowledge of the local tower).
  This message originates at a local tower and arrives at the relevant node.

The structure for `encContent` in MessageReceivedLocalTower is as follows:
- senderPublicKey (senderNodeId)
- encSymmetricKey == Encrypt{key=senderPrivateKey}(symmetricKey)
- encDatagramData == Encrypt{key=symmetricKey, nonce=random}(timestamp, datagramData)

## Messages between towers

The towers are the mechanism used for long range routing of messages.
Each tower should know the location of all other towers, to be able to route
messages quickly between towers.

- **UpdatedTowerPath**(originTowerColor, originTowerId, SignedPathFromTower)
  A message that is sent periodically from originTowerId. This message allows
  all towers in the network to know a path to originTowerId.
  This message is transferred using local tower based paths between towers.

- **StoreLookupId**(towerColor, SignedPathFromNode)
  Store ownership of nodeId in a tower. Allows for lookup later.

- **LookupIdRequest**(requesterTowerColor, requesterTowerId, nodeId)
  Find out which tower is responsible for the node nodeId.

- **LookupIdResponse**(requesterTowerColor, requesterTowerId, nodeId, 
  towerList of (towerColor, towerId))$
  Respond with the list of towers that have responsibility for nodeId.

- **RouteMessage**(nextTowerColor, destTowerColor, destTowerId, 
       destNodeId, encContent)
  Route a message between towers until it arrives at destTowerId.
  (Then destTowerId will send a MessageReceivedLocalTower to destNodeId)

## Protocol constants

- `SYM_KEY_CACHE_TIME = 30 minutes`: maximum amount of time an entry could be
  kept in symKeyMap cache.

- `MESSAGE_CACHE_TIME = 1 minute`: the maximum amount of time an entry could
  be kept in the messageCacheMap cache.

- `LOCAL_TOWER_EXPIRY = 1 minute`: The time it takes for knowledge of local
  tower to expire.

- `TOWER_ODD_BITS = 15`: The odds for a node to be a tower of a specific color
  are 2^(-TOWER_ODD_BITS).

- `NUM_COLORS = 32`: Amount of colors available for towers.

- `TOWER_TIME_BLOCK = 15 minutes`: Every
  such period towers of some color are replaced.


- `BATCH_TIME = 60 minutes`: Every such period of time
  a batch of network size approximation passes.

- `NET_APPROX_TIME = 5 minutes`: Time to approximate the amount of nodes in
  the network.

- `TOWER_CONVERGE_TIME = 10 minutes`: Time for convergence of towers
  information.

- `NUM_HEIGHT_FUNCS = 40`: Amount of random functions from nodeId into [0,1]


## Batch functions

```rust
Get the batchIndex of the current batch used for routing:
TODO: Check that this is still working:
routingBatchIndex(time) := (time / (BATCH_TIME / 2)) % 2

loadingBatchIndex(time) := 1 - routingBatchIndex(time)
```

## The towers selection functions

We assume that every node in the network has access to the current time in UTC
form. Given the current time (in seconds since epoch), `time`, we define:

```rust
tcolor(color, time) := ((time / TOWER_TIME_BLOCK) + color) / NUM_COLORS
```

Where `0 <= color < NUM_COLORS`.

For every passage of `TOWER_TIME_BLOCK`, the tcolor of only one color changes. In other
words, given some time `t_0` there is some color `c_0` such that `tcolor(c_0,t_0) +
1 = tcolor(c_0, t_0 + TOWER_TIME_BLOCK)`, and for every `c != c_0` we get that
`tcolor(c,t_0) = tcolor(c, t_0 + TOWER_TIME_BLOCK)`.

Next we define:

```rust
h(color, time) := sha256("AA" || tcolor(color, time) ||
                            "BB" || color)

isTower(nodeId, batchIndex, color, time) := sha256("CC" |  
                    h(color, time) || "DD" || sha256(nodeId) ||
                    "EE" || batchIndex) < 2^(256 - TOWER_ODDS_BITS)
```

During time `time`, a node `nodeId` is a tower of color `c` if `isTower(nodeId,
color, time)` is true.


## Network approximation functions

During the approximation of the network size we find the "height" of every node
in the network. There are `NUM_HEIGHT_FUNCS` random hash functions. We calculate
them as follows:

```rust
nodeHeight(heightIndex, nodeId) = (1 / num(sha256("FF" || heightIndex || 
                                    "EE" || sha256(nodeId)))) - 1
```

Using the height of the "lowest" nodes in the network we calculate an
approximation to the amount of nodes in the network.

```rust
approxNumNodes(heights) := harmonicMean(heights)
```

See also:
[demofox's blug](https://blog.demofox.org/2015/02/03/
estimating-counts-of-distinct-values-with-kmv/)
[sketch the day hyperloglog](https://research.neustar.biz/2012/10/25/
sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/)


## Maintained data structures for every node

Every node should keep the following:

- lowestNodes[heightIndex]
  A lowest known node for every index. These will be used for approximating the
  amount of nodes in the network.


Cache for receiving encrypted messages:

- symKeyMap[senderNodeId] == (encSymmetricKey, symmetricKey) 
  With `SYM_KEY_CACHE_TIME`, maximum amount of time an entry could be kept in
  symKeyMap cache.


Cache for message replay:

- messageCacheMap[encMsgHash] == timestamp
  With `MESSAGE_CACHE_TIME`, the maximum amount of time an entry could be kept in
  the messageCacheMap cache.


The following information is kept inside the structure batch[batchIndex]:

Information about network size approximation:

- lowestNodesPinned[heightIndex]
  A lowest known node for every index. May only be changed during the net
  approx time frame of the relevant batch.

- numNodesApprox
  An approximation for the amount of nodes in the network. Calculated from
  lowestNodes, after the net approx time frame has ended.

Information about local towers (Closest for each color):

- localTower[color].distance
  Shortest known distance to this local tower.

- localTower[color].gateways 
  A list of neighboring nodes: (nodeId, timestamp)

- localTower[color].towerNodeId: 
  The nodeId of the local tower.



Nodes that are towers also maintain the following for every batch:

- For every registered node:
    - registered[nodeId].registrationTime 
    Time of registration

    - registered[nodeId].path
    Path to registered node.

- For every tower (nodeId):
    - tower[nodeId].color
    The color of the remote tower.

    - tower[nodeId].distance
    Distance to remote tower. This is the length of the shortest path known to
    the remote tower.

    - tower[nodeId].colorGateways 
    Gateways to remote tower. Each gateway is a color of a local tower.


## Division of time in a single batch

For the operation of this protocol we assume some ability to synchronize time
between nodes. Note that this assumption is generally not valid for a strong
adversary. We assume that all nodes have a similar clock: the global UTC time. 

We choose the amount of towers based on an approximation of the amount of nodes
in the network. To avoid routing disruptions whenever a new approximation is
calculated, we perform the network size approximation in batches. At every
moment every node is taking part in two batches that run simultaneously (in
different stages), to make sure that routing is always operational.

A batch runs for `BATCH_TIME` minutes. It is divided to the following parts:


```
|---- NET_APPROX_TIME ----|-- TOWER_CONVERGENCE_TIME --|-- operational routing --|
```

If we denote by `=` the `NET_APPROX_TIME` period, by `*` the
`TOWER_CONVERGENCE_TIME` period and by `=` the "operational routing" period, we
should get a time diagram as follows for the two batches:

```
                    ---[time]--->

batch0:    ... =@****=@****=@****=@****=@**** ...
batch1: ... =@****=@****=@****=@****=@**** ...

```

Note that all times there is at least one batch in operational routing mode.
In addition, during the transitions between batches, the old batch is still in
operational routing mode.

The time period marked with `NET_APPROX_TIME` is the time where the network
size is approximated. In the beginning of this period, every node keeps a
snapshot of lowestNodes as lowestNodesPinned for the relevant batchIndex, and
then sends it to all of his neighbors. If a node encounters a better candidate
for lowestNodesPinned, he updates it and notifies his neighbors. 

In the end of `NET_APPROX_TIME` time period, lowestNodesPinned can not be
changed anymore. Hopefully it will be the same for all the nodes in the
network. `lowestNodesPinned` is then used to calculate `numNodesApprox`
is an approximation to the amount of nodes in the network. This is done by
applying the function `approxNumNodes`.

During `TOWER_CONVERGENCE_TIME`, nodes send each other the messages:
UpdatedLocalTowerPath and RegisterLocalTower. Nodes that are towers send
UpdatedTowerPath and StoreLookupId to each other. 

No user datagrams may be sent or received on this batch during the
`NET_APPROX_TIME` and `TOWER_CONVERGENCE_TIME` periods. 

During the "operational routing" period, this batch becomes usable for routing
and user datagrams may be routed.


## Algorithm for every node

The following represents an algorithm of operation for a node with node id
myNodeId.


### Receipt of external SendMessage (remoteId, datagramData):
```rust
- Use the current "operational routing" batch.
- Pick a set of three random tower colors: rcolors.
- for towerColor in rcolors:
    - Send a SendMessageLocalTower(towerColor, remoteId, datagramData) to a
      random gateway from the set localTower[towerColor].gateways.
```

### Receipt of LowestNodes(nodeList):

TODO

### Receipt of LowestNodesPinned(batchStartTime, nodeList):

TODO


### Receipt of SendMessageLocalTower(towerColor, destNodeId, encContent):

```rust
- Use the current "operational routing" batch.
- if localTower[towerColor].towerNodeId != myNodeId:
    - gatewayId, timestamp  <-- Sample randomly from 
        localTower[towerColor].gateways
    - Send SendMessageLocalTower(towerColor, destNodeId, encContent) to the
      neighbor gatewayId.
    - return

// Here if we are a tower:

- Send LookupIdRequest(towerColor, myNodeId, destNodeId)
- Wait for 
    LookupIdResponse(requesterTowerColor, requesterTowerId, nodeId, towerList)
  with  requesterTowerColor == towerColor &&
        requesterTowerId == myNodeId &&
        nodeId == destNodeId

- (rTowerColor, rTowerId) <-- Sample randomly from towerList
- colorGateway <-- sample randomly from tower[rTowerId].colorGateways
- gateway <-- sample randomly from localTower[colorGateway].gateways
- Send RouteMessage(colorGateway, rTowerColor, rTowerId, 
       destNodeId, encContent) to gateway
```

### Receipt of MessageReceivedLocalTower(nodeIdPath, encContent):

```rust
- if nodeIdPath != []
    - nextNode <-- nodeIdPath[-1]
    - Send a MessageReceivedLocalTower(nodeIdPath[:-1], encContent) to the
      node nextNode.
    - return

- encMsgHash <-- sha256(encContent)
- if encMsgHash in messageCacheMap:
    - return

- symmetricKey <-- Decrypt{key=senderPublicKey}(encSymmetricKey)
- if encContent.senderPublicKey not in symKeyMap
    - symKeyMap[encContent.senderPublicKey] <--
             (encContent.encSymmetricKey, symmetricKey)

- if encContent.encSymmetricKey != symKeyMap[encContent.senderPublicKey].encSymmetricKey:
    - symKeyMap[encContent.senderPublicKey] <--
        (encContent.encSymmetricKey, symmetricKey)

- timestamp, datagramData <-- Decrypt{key=symmetricKey}(encContent.encDatagramData)
- if Decrypt failed, return.

- if curTime - timestamp > `MESSAGE_CACHE_TIME`, return

- messageCacheMap[encMsgHash] <-- timestamp

- Send external MessageReceived(senderPublicKey, datagramData)
```


### Receipt of UpdatedLocalTowerPath(towerColor, SignedPathFromTower):

```rust
- if curTime - SignedPathFromTower.timestamp > `LOCAL_TOWER_EXPIRY`
    - return

- Check all signatures. If any signature is invalid, return.
- Verify that the last signature signs over myNodeId. Otherwise, return.

- distance      <-- length of path.
- gateway       <-- last nodeId on chain before myNodeId.
- towerNodeId   <-- first nodeId on the path.
- timestamp     <-- path timestamp.

- if not isTower(towerNodeId, color, curTime):
    - return

- Remove gateways from `localTower[towerColor].gateways` that are older than
  `LOCAL_TOWER_EXPIRY`.

- if len(localTower[towerColor].gateways) == 0:
    - localTower[towerColor] <-- None

- if localTower[TowerColor] is None:
    - localTower[towerColor].distance       <-- distance
    - localTower[towerColor].gateways       <-- set{(gateway, timestamp)}
    - localTower[towerColor].towerNodeId    <-- towerNodeId

    - for neighborId in neighbors:
        - send UpdatedLocalTowerPath(towerColor, SignedPathFromTower
            + (neighborId, sign{myNodeId}(neighborId, prev)) )
    - return

- if distance > localTower[towerColor].distance:
    - return

- if distance < localTower[towerColor].distance:
    - localTower[towerColor].distance       <-- distance
    - localTower[towerColor].gateways       <-- set{(gateway, timestamp)}
    - localTower[towerColor].towerNodeId    <-- towerNodeId

    - for neighborId in neighbors:
        - send UpdatedLocalTowerPath(towerColor, SignedPathFromTower
            + (neighborId, sign{myNodeId}(neighborId, prev)) )
    - return

- if distance == localTower[towerColor].distance:
    - localTower[towerColor].gateways.insert((gateway, timestamp))
    - for neighborId in neighbors:
        - send UpdatedLocalTowerPath(towerColor, SignedPathFromTower
            + (neighborId, sign{myNodeId}(neighborId, prev)) )
    - return
```


### Receipt of RegisterLocalTower(towerColor, SignedPathToTower):




## TODO area:

TODO: Start with messages between routing engines.
Explain what to do when a message is received.

Explain any periodic behaviour, related to time, like registration.

If a longer path of registration passes through a node, the node will delay his
next registration message, hoping that the same large message will pass again.
This is done to save bandwidth.


TODO: **probes**: Add a mechanism to make sure that towers actually pass messages. Every
node should sometimes send probes: Marked messages (Encrypted) sent through
various towers. He then gets acks for those messages. This way a node can know
which towers are the most reliable, and he will use mostly those towers. Towers
that don't pass messages will get less and less messages.

How to design the probe messages?

