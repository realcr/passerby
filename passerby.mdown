
# Passerby messaging system
By real@freedomlayer.org, freedomlayer research facility.
15.07.2017

## Abstract

Passerby is an experimental messaging system that allows real time anonymous
and encrypted messaging. This document describes the protocol being used in
Passerby.

## Main goals

Main goals of the Passerby system:

- Passing messages between people with high probability of success.
- Encrypting the messages passed between people.
- Keeping a contact list.


## External API messages

Possible messages to send to the Passerby router:

- SendMessage (remoteId, datagramData)

Possible messages to receive from the Passerby router:

- MessageReceived (remoteId, datagramData)

Node ids are of size 120 bits (15 bytes). They are a hash of a public key.


## Protocol routing messages

The structure of a message:

- magic
- messageType
- length (of payload, in bytes)
- payload

## Messages between routing engines

The Passerby router has direct reliable TCP like connections to various nodes,
implemented somehow. For any direct connection with a neighboring node, the
following messages can be transferred:

-   **UpdatedLocalTowerPath**(towerColor, towerIndex, SignedPathFromTower)
    Used both for new choice of a local tower, or changes in the network
    layout. This message is sent periodically, originating from tower nodes.

    ```
    localTower,   timestamp                  
    a_1,          sign[localTower](a_1, prev)
    a_2,          sign[a_1](a_2, prev)       
    \cdots                                   
    a_k,          sign[a_{k-1}](a_k, prev)
    ```

-   **RegisterLocalTower**(towerColor, SignedPathToTower)
    A node registers with a local tower.
    ```
    nodeId,       timestamp              
    a_1,          sign[nodeId](a_1, prev)
    a_2,          sign[a_1](a_2, prev)   
    \cdots                               
    localTower,   sign[a_{k-1}](localTower, prev)
    ```
    The local tower will keep knowledge of paths to all nodes in the given
    chain of signatures.

-   **SendMessageLocalTower**(towerColor, destNodeId, content)
    Send a message with given content to a destination id.
    This message will be first passed to the closest local Tower of color
    towerColor. The towers will then handle the messages delivery. This message
    originates at some node and arrives at a local tower.

-   **MessageReceivedLocalTower**(NodeIdPath, encContent)
    A message received through the local tower with given content.
    IdPath is a list of Ids that show how to route the message to the correct
    id (According to the knowledge of the local tower).
    This message originates at a local tower and arrives at the relevant node.

The structure for `encContent` in MessageReceivedLocalTower is as follows:
- senderPublicKey (senderNodeId)
- encSymmetricKey == Encrypt{key=senderPrivateKey}(symmetricKey)
- encDatagramData == Encrypt{key=symmetricKey, nonce=random}(timestamp, datagramData)

## Messages between towers

The towers are the mechanism used for long range routing of messages.
Each tower should know the location of all the other towers, to be able to route
messages quickly between towers.

-   **PathFromTowerLocal**(destTowerColor, originTowerColor, originTowerIndex, 
    SignedPathFromTower)
    A path from remote local tower, sent to the closest tower of color destTowerColor.

-   **LookupIdRequest**(RequesterTowerColor, RequesterTowerIndex, nodeId)
    Find out which tower is responsible for the node nodeId.

-   **LookupIdResponse**(RequesterTowerColor, RequesterTowerIndex, nodeId, 
    [(TowerColor, TowerId)])$
    Respond with the list of towers that have responsibility for nodeId.

-   **RouteMessage**(destTowerColor, destTowerIndex, destNodeId, encContent)
    Route a message between towers until it arrives at destTowerId.
    (Then destTowerId will send a MessageReceivedLocalTower to destNodeId)


## The towers selection functions

We assume that every node in the network has access to the current time in UTC
form. Given the current time (in seconds since epoch), $time$, we define:

```
tcolor(color, time) := ((time / timeBlock) + color) / numColors
```

We choose timeBlock to be `900` seconds, which are 15 minutes. We also choose
`numColors` to be the first power of `2` that is greater or equal than
`2 * log(sqrt(n))`, assuming that `n` is the amount of nodes in the network. 
(Chosen for connectivity of towers). `0 <= color < numColors`.

For every passage of `timeBlock`, the tcolor of only one color changes. In other
words, given some time `t_0` there is some color `c_0` such that `tcolor(c_0,t_0) +
1 = tcolor(c_0, t_0 + timeBlock)`, and for every `c != c_0` we get that
`tcolor(c,t_0) = tcolor(c, t_0 + timeBlock)`.

Next we define:

```
h(color, index, time) := sha256("AA" | tcolor(color, time) | 
                            "BB" | color | "CC" | index )

towerNodeMatch(nodeId, color, index, time) := sha256("DD" |  
                    h(color, index, time) | "EE" | sha256(nodeId))
```


During time `time`, the tower with color `c` and index `i` is the node that
minimizes the value of `towerNodeMatch(nodeId, c, i, time)` (Considered as a
number in big endian notation). If there is a tie, the value $nodeId$ is used as
a tie breaker.

## Protocol constants

- `SYM_KEY_CACHE_TIME = 30 minutes`: maximum amount of time an entry could be
  kept in symKeyMap cache.

- `MESSAGE_CACHE_TIME = 60 seconds`, the maximum amount of time an entry could
  be kept in the messageCacheMap cache.

- 


## Maintained data structures for every node

Every node should keep the following:

Information about local towers (Closest for each color):
-   localTower[color].distance
    Shortest known distance to this local tower.

-   localTower[color].gateways 
    A list of neighboring nodes.

-   localTower[color].towerNodeId: 
    The nodeId of the local tower.

Cache for receiving encrypted messages:
-   symKeyMap[senderNodeId] == (encSymmetricKey, symmetricKey) 

With `SYM_KEY_CACHE_TIME`, maximum amount of time an entry could be kept in
symKeyMap cache.

Cache for message replay:
-   messageCacheMap[encMsgHash] == timestamp

With `MESSAGE_CACHE_TIME`, the maximum amount of time an entry could be kept in
the messageCacheMap cache.


Nodes that are towers also maintain the following:

- For every registered node:
    - registered[nodeId].registrationTime
        Time of registration

    - registered[nodeId].path
        Path to registered node.

-   For every tower (color, index):
    - tower[(color, index)].distance
        Distance to remote tower.

    - tower[(color, index)].gateways 
        Gateways to remote tower. Each gateway is a color of a local tower.


## Algorithm for every node

The following represents an algorithm of operation for a node with node id
myNodeId.

Receipt of external SendMessage (remoteId, datagramData):
-   Pick a set of three random tower colors: rcolors.
-   for towerColor in rcolors:
    -   Send a SendMessageLocalTower(towerColor, remoteId, datagramData) to
        a random gateway from the set localTower[towerColor].gateways.


Receipt of MessageReceivedLocalTower(nodeIdPath, encContent):
-   if nodeIdPath != []
    -   nextNode <-- nodeIdPath[-1]
    -   Send a MessageReceivedLocalTower(nodeIdPath[:-1], encContent) to the
        node nextNode.
    -   return

-   encMsgHash <-- sha256(encContent)
-   if encMsgHash in messageCacheMap:
    -   return

-   symmetricKey <-- Decrypt{key=senderPublicKey}(encSymmetricKey)
-   if encContent.senderPublicKey not in symKeyMap
    -   symKeyMap[encContent.senderPublicKey] <--
             (encContent.encSymmetricKey, symmetricKey)

-   if encContent.encSymmetricKey != symKeyMap[encContent.senderPublicKey].encSymmetricKey:
    - symKeyMap[encContent.senderPublicKey] <--
        (encContent.encSymmetricKey, symmetricKey)

-   timestamp, datagramData <-- Decrypt{key=symmetricKey}(encContent.encDatagramData)
-   if Decrypt failed, return.

-   If curTime - timestamp > `MESSAGE_CACHE_TIME`, return

-   messageCacheMap[encMsgHash] <-- timestamp

-   Send external MessageReceived(senderPublicKey, datagramData)



Receipt of UpdatedLocalTowerPath(towerColor, towerIndex, SignedPathFromTower):




## TODO area:

TODO: Start with messages between routing engines.
Explain what to do when a message is received.

Explain any periodic behaviour, related to time, like registration.

If a longer path of registration passes through a node, the node will delay his
next registration message, hoping that the same large message will pass again.
This is done to save bandwidth.


TODO: **probes**: Add a mechanism to make sure that towers actually pass messages. Every
node should sometimes send probes: Marked messages (Encrypted) sent through
various towers. He then gets acks for those messages. This way a node can know
which towers are the most reliable, and he will use mostly those towers. Towers
that don't pass messages will get less and less messages.

How to design the probe messages?

